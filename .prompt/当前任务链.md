我在设计一个编程语言。
思路是先创建一个类似lisp,xml,json结合体的数据格式，便于灵活的调整语义设计，而无需修改语法解析器
这个数据格式下文中可以统称为kon

目前已经将kon解析器代码放到了src/Kon.Core, 其测试case在tests/Kon.Core.Tests


我希望你能参考我之前编写的一个使用面向数据编程思路，以及参考面向栈的编程语言的双栈（指令栈、操作数栈）思路的解释器，这种解释器因为是面向数据编程，比较容易实现continuation等概念
给kon数据格式，添加脚本执行能力
要参考的解释器，代码在当前项目的kunun.ts下，注意这个解释器的数据格式不是kon，而是有些差别的语法

注意
我只是要用kon格式，参考我原来解释器的解释执行部分的思路，重新写解释器，不能修改kon的解析器。如果有解析问题，请告中断，问我是否要先修复kon解析器的问题再继续
原kunun.ts中的某些逻辑可能有错，以最终能够通过测试case，特别是参考 KonParserTests.cs 中的 ChainUseAsScript中我期望的目标为导向

请参考kunun.ts执行思路的新的基于kon的解释器，
放到src下, 创建一个Kon.Interpreter project
并在tests下，创建Kon.Interpreter.Tests存放测试case。
在测试case中，应当参考 KonParserTests.cs 中的 ChainUseAsScript，使用c#的多行文本来编写kon代码

你不可以一次性的把所有kunun.ts的解释思路还原，需要分步
1，先进行数据建模，比如将解释器的XnlState以及关联的下层对象改为KonLangRuntime
2，还原单个表达式的执行，能够参考我在ChainUseAsScript期望的方式，使用
前缀表达式函数调用(KsCallType.PrefixCall)、栈操作表达式(KsCallType.PostfixCall)，执行内置几个数学计算、字符串处理、io输出函数.
对象方法调用表达式(KsCallType.InstanceCall)，调用内置给脚本使用的KsArray的Length方法
3，还原没有控制结构的代码block的执行
4，还原没有控制结构的函数的定义和执行
5，还原if-else, cond
6, 还原变量的定义，set, get能力
7, 支持脚本对KsArray， KsMap对象的下标计算（KsCallType.ContainerSubscript）
8, 还原continuation机制
9, 基于continuation机制，还原foreach、for、continue、break
10, 基于continuation机制，还原return
11，基于continuation机制，还原try-handle-catch（PerformResumeWithoutAsync.kn），添加简单的throw error能力
12，还原Fiber处理，结合continuation机制，还原async，await

不需要还原kunun.ts中的自定义对象，以及自定义对象的更新、调用方法等操作

我严格要求你，依次先阅读src/Kon.Core 、tests/Kon.Core.Tests 、kunun.ts，再进行代码编写

每个阶段代码编写完毕，都需要编写和运行单元测试。在测试case都通过后，中断等我验证，我确认无误后，再提交代码，进入下一阶段
