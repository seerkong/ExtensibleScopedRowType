我在网上看到了一个介绍类型系统设计的帖子，我希望你能够使用C#语言，.net core 8.0, language version 12，来实现这个语言的一个解释器和类型系统。语法上应当基于javascript的语法做扩展。我希望达成的类型系统
注意要创建一个C# solution, 包含3个c# project：
1 核心逻辑project
2 对这个解释器的命令行封装
3 单元测试case

每次一个核心流程跑通，或者添加一个feature，都需要编写和运行单元测试。在测试case都通过后，自动提交代码


<quote>
作者：酱紫君
链接：https://www.zhihu.com/question/578471046/answer/3081209476
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Row Type快用 Extensible Scoped Row TypeMake OO Great Again行类型(row type) 顾名思义就是一行一行的类型.

type T = {
    a: () -> int, 
    b: () -> str,
}

T.a() // int
T.b() // str啊, 就这? 这不 interface 吗?别急, row type 还可以合并, 我们用 & 表示把右边的 rows 全加到左边.

type T1 = {
    a: () -> int, 
    b: () -> str,
}
type T2 = {
    b: () -> int,
    c: () -> bool,
}
type T3 = T1 & T2 = {
    a: () -> int, 
    b: () -> str,
    b: () -> int,
    c: () -> bool,
}

T3.b() // ???

啊? 这不冲突了吗? 编译器怎么知道要调用哪个?别急, 我们追踪每个 row 的来源, 写成这个形式

:type T3 = T1 & T2 = {
    T1::a: () -> int, 
    T1::b: () -> str,
    T2::b: () -> int,
    T2::c: () -> bool,
}

(T3 as T1)::b   // str
(T3 as T2)::b() // int
T3.b()          // str

我们规定, 查找到第一个符合的就行, 找不到就报错.我们称这套类型系统为 scoped row type.至于什么叫 extensible row.就是说 row 可以参数化, 比如说
type T1<P, Q> = {
    a: () -> P, 
    b: () -> str,
    ..Q
}
因为一般开 row 比闭 row 更常见, 所以我们省略 .., 如果要闭 row, 可以用 ..never 表示.Subtypingrow type 是一种结构化类型, 也就是传说中的静态鸭子类型.如果类 A 中所有的 row 另一个类 B 全部都有, 那么我们称 A <: B.这和 A, B 是否是继承实现的完全没有关系, 无论 B 是传统的继承类型, 还是继承的原始类型, 还是匿名类型都成立.说回继承, 生成子类型最常规的方法就是继承.类继承分为实继承和虚继承实继承: 父类存为成员变量, 接口不需要重新实现, 调用直接转发给父类即可.虚继承: 父类不存在, 接口需要重新实现.实继承可以带访问修饰符来决定成员变量的访问权限private: class level, 只能类内部访问protect: package level, 只能同级模块和子模块访问internal: package level, 只能包内部访问public: 可以任意访问举个例子, 如下继承关系

class K1(A, B) { }
class K2(virtual A, public B) { };
编译期展开后为
class K1 {
    private _a: A
    private _b: B
}

class K2 {
    public b: B
}

Method Resolve Order你看这里出现了多多继承, 我们需要解析方法的调用顺序, 特别是菱形继承的情况下.解析需要遵从三个原则 (Consistent)扩展一致性原则局部优先原则单调性原则满足这三个原则的算法就是 C3 线性化算法, 解析结果称为方法解析序(MRO, Method Resolution Order).比如说这个图

class A(object) {}
class B(object) {}
class C(object) {}
class D(object) {}
class E(object) {}
class K1(C, A, B) {}
class K2(B, D, E) {}
class K3(A, D) {}
class Z(K1, K3, K2) {}

<img src="https://picx.zhimg.com/50/v2-e7ad44d3ed989f45d2a94db8a17a6745_720w.jpg?source=2c26e567" data-caption="" data-size="normal" data-rawwidth="1267" data-rawheight="444" data-original-token="v2-e7ad44d3ed989f45d2a94db8a17a6745" data-default-watermark-src="https://picx.zhimg.com/50/v2-deb47fe9f6f381f35c885be21c33ca66_720w.jpg?source=2c26e567" class="origin_image zh-lightbox-thumb" width="1267" data-original="https://pic1.zhimg.com/v2-e7ad44d3ed989f45d2a94db8a17a6745_r.jpg?source=2c26e567"/>

其 mro 应为 [Z, K1, C, K3, A, K2, B, D, E, object]可以发现, mro 其实就是 row 这里面同名 row 的排列顺序.Type Class我们可以定义一些不参与 mro 排序的类, 这些类的 row 指针永远指向最上方.
trait ToString {
    def to_string(self): str
}
class A: ToString {
    def to_string(self): str { "A" }
}
class B(A) {
    private _b: B
    def to_string(self): str { "B" }
}

// MRO = B, A
typeof(B) = {
    B::to_string: (self) -> str,
    A::to_string: (self) -> str,
}

let b = B();

B::to_string(b)        // "B"
ToString::to_string(b) // "B"
A::to_string(b)        // "A"

这里的 ToString 实质上就是起到了 type class 的效果.等会儿, ToString::to_string 指向最上方返回 "B" 我能理解, 为什么还能调用 A::to_string 返回 "A" 呢?这是因为 B 代理了 A 的指针, 在 scoped type system 里会自动转发.如果要禁掉这种转发那就用虚继承即可.这告诉我们, 还缺一套精确控制 row 转发的机制.Method Resolve Qualifier在类型层面, 简单起见, 我们把字段属性看成方法的一种, 我们不区分以下两者:field: T
field(): T实继承的情况下, 方法可以有如下几种修饰词_: 不写, 默认转发父类同名方法inherit: 手动转发virtual: 无法调用, 子类必须重写, 除非子类是虚基类override: 重写父类方法, 除非父类方法是 final 方法final: 原则上禁止重写来看一些例子, 我这里加上 123 的编号省的分不清, 实际上通过 & 附加的时候不带编号

type A = {
    inherit a1: str
    virtual a2: str
    // A::a 报错, A::a 转发 A2::a 且其是虚方法无法调用
}
type B = {
    override b1: str
    final b2: str
    // B::b 报错, 禁止重写 final 方法
}
type C = {
    override c1: str
    virtual c2: str
    // C::c 返回 c1
    // C2::c 报错, c1 是虚方法无法调用
}

可以发现一虚皆虚, 编译期可以直接干掉虚方法后面的所有 row.Effect System为什么 Row Type 总和 Effect System 扯上关系呢?因为此时异步类型可以写成这个奇行种:

type File = {
    read: str,
    async read: str,
    ..IoError,
    ..Print,
}

这个就比较离奇了, sync 的环境下读上面一个 read, async 的环境下读下面一个 read.
我超, contextual effect polymorphism.

然后其他你不想管的 Error 可以直接挂 extension 里面, 传来传去也不会丢失.我超, colorless function

如果有兴趣处理错误可以直接 pick 然后创建一个新的 row type 把你不感兴趣的继续挂着.我超, try catch exceptions

传到最后身上还挂着什么没处理的 effect 一目了然我超, checked exceptions.

</quote>


----------------


