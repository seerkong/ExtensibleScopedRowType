目前的实现已经覆盖了
* row 合并
* 来源追踪
* 行类型 spread (.. / ..never)
* 方法限定词（inherit/virtual/override/final）
* C3 MRO
* trait 行为
* 运行期 effect scope

等核心，但对照原文仍有下列空缺，待实现：

* 行类型泛型／开放行参数

原文示例 type T1<P, Q> = { … ..Q } 中的类型参数与开放行并未支持。我们还不能在 row-type 定义中声明类型参数、约束或在类上实例化这些泛型 row。

* 同步/异步双语义的行成员（contextual effect polymorphism）
文中 type File = { read: str, async read: str, ..IoError, ..Print } 期待同名 row 在不同上下文（同步/异步）选择不同实现。现阶段我们只能通过函数签名的 effect 列表控制调用权限；尚未实现以 async 标记同名成员、并根据运行状态切换解析顺序的机制。

* 效果行的组合与“colorless function”/“pick”语义
虽可在 run 中声明允许的 effect，但还缺少把 effect 当作行成员进行聚合、挑选（pick）或分流的能力；也没有 “try/pick/merge” 这一套 effect row 操作与检视剩余 effect 的功能。

* method qualifier 的静态裁剪
原文提到 “一虚皆虚，编译期可以直接干掉虚方法后面的所有 row”。我们目前保留了虚方法并在运行时检查，但还没实现编译期去除、以及对虚基类特殊处理的优化。

* 继承限定更细粒度的访问控制
解析器允许 (bases (Base virtual public)) 一类语法，但 runtime 对 private/protected/internal 访问界限尚未真正 enforcing。

* 更丰富的 type class 示例与 as 投影语法
Trait 支持基本可用，不过原文里的 (T3 as T1)::b 风格、以及 CLI 示例中的类型类转换尚未通过 KON 显式演示，也缺少脚本-side 的 as 投影语法糖。

* 异常／错误行的“try-catch”式处理
文章结尾的 “pick 某个 error 再挂回去”、“checked exceptions” 需要在解释器层面提供 effect 行的选择、重新包装与传递，目前还没有这套语义。
