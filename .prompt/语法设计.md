为了实现前面介绍的这个编程语言类型系统，以及解释器的开发过程中，不要将过多精力和复杂性放在语法解析层面上，我希望这个语言的原型，是一个基于s-expr，再添加一些定制性的语法扩展，下文统称为 kon 语法

相比s-expr，kon的主要扩展点是：

1 对于每个identifier, 支持使用:: 表示namespace, 例如 a::b::c
2 在kon的identifier和list之前，能够通过! 字符添加前缀注解，通过^字符添加后缀注解，这个前缀、后缀可以是任意kon节点，可以无限前后追加

例如
!(a b c) !opq (x y z) ^abc ^(e f g)
!(a b c) !opq xyz ^abc ^(e f g)

3 每个标识符后面可以通过 ~ 后缀，表示类型
例如
abc ~ str
myMap ~ (Map [str str])

4 在list之外，还支持数组和键值对结构 
为了便于用这个kon表示这个语言的数据结构,加上表示键值对和表示数组的语法
相比json，区别是可以省略逗号， key-value的分隔符是'='，并且key可以是identifier: 
[1 2 "3"]
{k1 = 1 k2 = 2 ABC::k3 = [1] "key4" = {}} 

5 通过这种kon语法，带来的灵活性，你可以参考lisp系语言，如何利用这种灵活的表达方式，自定义适合ExtensibleScopedRowType的语法，降低解析器、解释器的开发成本 

解释器功能方面，使用这种kon语法，参考javascript的语义来实现核心功能，并且要能利用这些功能，覆盖到这个ExtensibleScopedRowType类型系统。

当前已经支持的核心表单与语义补充：

- `(row-type Name ... )`：定义开放或封闭的行类型，可通过 `(extends [Base...])` 继承现有行；`(field identifier ~ Type)` 与 `(method ...)` 子句描述结构。
- `(let ((name expr) ...) body...)`：创建词法作用域的绑定，用于中间计算、复用数组 `{}` 和数组 `[]` 结构。
- `(call target MemberName [args...])`：显式触发对象上的 row 调度，`MemberName` 支持 `Origin::method` 形式来指定作用域。
- `(new ClassName)`：根据类型系统生成实例，并自动完成继承链上的 row 聚合。
- `(+ ...) (- ...) (* ...) (/ ...)`：针对 `int` 值的算术原语，`-` 在单参数时表示取负。
- `(concat expr ...)`：把多个值拼成字符串，`int`、`bool`、字符串及 `let` 绑定的结果都会按需转换。
- `(run Class member (effects ...))`：在脚本入口指定要执行的 method，必要时通过 `(effects ...)` 声明执行时允许的效果集合。
- `map.property`：在方法体中可通过点号访问由 `{}` 构造的映射字段，从 `let` 绑定或运行时对象中提取嵌套值。
- `(access <modifier>)`：在 `method` 或 `field` 中声明 `private`/`protected`/`internal`/`public` 访问级别；配合 `Origin::member` 或宿主函数 `$` 完成受控访问。
- `class Name ~ RowType ^(extends Base...)`：类定义可声明实现的行类型及需要挂载的基类，实现继承与行类型匹配校验。
- `$`：宿主函数，用于发送消息；`($ instance Member args...)` 等价于 `Member(instance, args...)`，支持 `Origin::member` 的显式调度。

这些表单与 kon 的注解、数组、键值对语法配合，可用于测试、脚本和 CLI 场景来描述 richer 的上下文数据。
